"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAttestation = exports.checkIfSchemaExist = exports.CREDENTIALS_PALLET_NAME = void 0;
const hashing_1 = require("../../utils/hashing");
exports.CREDENTIALS_PALLET_NAME = 'credentialsModule';
const checkIfSchemaExist = (api, schemaHash) => __awaiter(void 0, void 0, void 0, function* () {
    const response = yield api.query[exports.CREDENTIALS_PALLET_NAME].schemas(schemaHash);
    const data = response.toJSON();
    if (!data || data.length == 0)
        return false;
    return true;
});
exports.checkIfSchemaExist = checkIfSchemaExist;
// TODO: implement the below method, to return instance of Schema Class.
// export const getSchema = async (api: ApiPromise, schemaHash: string): Promise<SchemaObject | undefined> => {
//   const response = await api.query[CREDENTIALS_PALLET_NAME].schemas(schemaHash);
//   const data = (response.toJSON() as any)
//   if (!data || data.length == 0) return;
//   const schema: any = {}
//   data.forEach((i: any[]) => {
//     const key = convertHexToString(i[0])
//     const schemaType = stringToSchemaType(i[1])
//     if (!schemaType) throw Error("Invalid schema type coming from nodes.")
//     schema[key] = schemaType
//   })
//   return schema
// }
const getAttestation = (api, account, schemaHash) => __awaiter(void 0, void 0, void 0, function* () {
    const response = yield api.query[exports.CREDENTIALS_PALLET_NAME].attestations(account, schemaHash);
    const data = response.toJSON();
    if (!data || data.length == 0)
        return;
    const cred = [];
    data.forEach((i) => {
        const value = parseFloat((0, hashing_1.convertHexToString)(i));
        if (Number.isNaN(value)) {
            cred.push((0, hashing_1.convertHexToString)(i));
        }
        else {
            cred.push(value);
        }
    });
    return cred;
});
exports.getAttestation = getAttestation;
// TODO: need to implement this later.
// export const getAllAttestations = async (api: ApiPromise, account: string): Promise<SchemaObject | undefined> => {
//   const response = await api.query[CREDENTIALS_PALLET_NAME].attestations(account);
//   const data = (response.toJSON() as any)
//   if (!data || data.length == 0) return;
//   const schema: SchemaObject = []
//   data.forEach((i: any[]) => {
//     const key = convertHexToString(i[0])
//     const schemaType = stringToSchemaType(i[1])
//     if (!schemaType) throw Error("Invalid schema type coming from nodes.")
//     schema.push({
//       key: key,
//       type: schemaType
//     })
//   })
//   return schema
// }
